#!/usr/bin/env python3
#
# Reduces Rust compiler warning verbosity where I find it detrimental.
#
# The usage of this script is unfortunately not very straightforward. You need to see
# the `dotfiles/bin/ck` script in this repository to see how to invoke this and show the results.
#
# Development note to self:
# * `cd` to the cargo workspace folder you are debugging, and run `ck check debug`.
# * Modify this script to print something when `args.debug` is True.
# * Run `ck check` to see how your modifications changed the filter outputs.

import json
import re
import subprocess
import sys

RE_ERROR_EXPLANATIONS = re.compile(r"Some errors have detailed explanations: (.*)\.")

# Print a Python object using `jq`.
# Uses a temporary file to avoid character escaping issues.
def jqPrint(j):
  import tempfile
  # TODO Should work with tempfile, but doesn't (only in some cases?).
  # with tempfile.NamedTemporaryFile(mode="w") as tempFile:
  with open("/tmp/filter-rustc", "w") as tempFile:
    s = json.dumps(j)
    tempFile.write(s)

  with open("/tmp/filter-rustc") as tempFile:
    content = tempFile.read()
    # -C: color
    out = subprocess.check_output(f"cat {tempFile.name} | jq -C .", shell=True).decode('utf-8').strip()
  print(out)

# Print the error as it will show in the rustc output.
def print_rustc_rendered(item):
  if not "rendered" in item: return
  print(item["rendered"])

def readJson(filePath):
  with open(filePath) as f:
    return json.load(f)

# One nice reference: <https://stackoverflow.com/a/21786287>
def colorWarning(s): return "\x1b[33m" + s + "\x1b[0m"
def colorError(s):   return "\x1b[31m" + s + "\x1b[0m"
def colorMeta(s):    return "\x1b[37m" + s + "\x1b[0m"

def printWarning(item):
  item = item.copy()
  del item["rendered"]
  print(json.dumps(item, indent=4))

def replaceRendered(item, s, error=False):
  if error: item["rendered"] = colorError(s)
  else: item["rendered"] = colorWarning(s)

def getCodeLocations(item):
  locs = []
  if "spans" in item:
    for i, span in enumerate(item["spans"]):
      loc = "{}:{}".format(span["file_name"], span["line_start"])
      if loc not in locs:
        locs.append(loc)

  s = ""
  if locs:
    for i, loc in enumerate(locs):
      if i > 0: s += ", "
      s += loc
  return s

def render(item, locations, message):
  if item["level"] == "error": s = colorError(locations)
  else: s = colorWarning(locations)
  s += f": {message}"
  item["rendered"] = s

# Generic compression that shows the plain "message" field.
def compress(item):
  locations = getCodeLocations(item)
  s = "{}".format(item["message"])
  if len(s) > 100: s += "\n"
  replaceRendered(item, s, item["level"] == "error")
  render(item, locations, s)

def filterWrongNumberOfArguments(item):
  locations = getCodeLocations(item)
  s = ""
  found = False
  for span in item["spans"]:
    if span["label"] is not None:
      s += span["label"]
      found = True
  assert(found)

  s += ". Expected these arguments:"
  child = item["children"][0];
  for span in child["spans"]:
    if span["label"] is None: continue
    s += "\n    " + span["text"][0]["text"].strip()
  s += "\n"
  render(item, locations, s)

def filterValueTypo(item):
  if "children" in item:
    for child in item["children"]:
      for span in child["spans"]:
        if not "suggested_replacement" in span: continue
        item["message"] = colorWarning("Typo? -> {}".format(span["suggested_replacement"]))
        compress(item)

def filter(args, item):
  m = item["message"]
  code = None
  if "code" in item and isinstance(item["code"], dict):
    code = item["code"]["code"]

  # rustc takes 7 lines of output per unused variable, which is extremely verbose
  # considering it's routine to have them when writing new code. Condense to one line.
  if code == "unused_variables" or m.startswith("unused variable"):
    compress(item)

  if m.startswith("cannot find value"):
    filterValueTypo(item)

  if code == "E0061" or m.startswith("this function takes"):
    filterWrongNumberOfArguments(item)

  # NoSuchEnumVariant
  if code == "E0599":
    compress(item)

  # Compress advice about errors into copy-paste ready commands.
  if m.startswith("For more information about an error"):
    return None
  m = RE_ERROR_EXPLANATIONS.match(m)
  if m:
    tokens = m.group(1).split(",")
    s = "Help: "
    for i, token in enumerate(tokens):
      if i > 0: s += "; "
      s += f"rustc --explain {token.strip()}"
    replaceRendered(item, s)

  return item

def main(args):
  with args.input as f:
    content = f.read()
  data = json.loads(content)

  output = []
  for item in data:
    try:
      item = filter(args, item)
    except:
      if item is not None:
        output.append({
          "rendered": colorMeta("filter-rustc failed to process a message, showing the original:"),
        })

    if item is not None:
      output.append(item)

  if args.debug:
    pass
    #print(output)
  else:
    print(json.dumps(output, separators=(',', ':')))

if __name__ == "__main__":
  import argparse
  p = argparse.ArgumentParser(__doc__)
  p.add_argument(
      '--input',
      type=argparse.FileType('r'),
      default=sys.stdin,
      help="Path to input file or else use stdin.",
  )
  p.add_argument("--debug", action="store_true")
  args = p.parse_args()
  main(args)
