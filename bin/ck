#!/bin/bash
#
# Parse and filter Rust `cargo check` (or `cargo <command>`) output for development aid.
# See also `dotfiles/bin/cw` which runs this script in a "watch" loop.
#
# Example:
#   cd my-rust-project
#   ck
#
# will show filtered results of `cargo check` and save an `.errorlines` file
# (see the `.vimrc` file for an example what to do with the errorlines files).
#
# You can also use this with clippy:
#   ck clippy
#
# In theory `ck run` should also work as wrapper for `cargo run`, but currently the output isn't parsed(?).

cargo_command=${1:-check} # Use eg "build", "clippy", or "run". The default is "check".

# For developing `filter-rustc`.
debug=${2:-off}

for prog in git cargo jq sed; do
  if ! type $prog > /dev/null 2>&1; then
    echo "command not found: $prog"
    exit 0
  fi
done

dir=$(git rev-parse --show-toplevel 2> /dev/null || echo ".")

# Run rustc via cargo. Taking the output in JSON format suppresses normal output.
output=$(cargo $cargo_command --message-format=json-diagnostic-rendered-ansi 2> /dev/null)

# Discard (lots of) top level data that we are not interested in.
messages=$(echo "$output" | jq 'select(.reason=="compiler-message") | .message')

# Could somehow be merged with the previous but I'm not good with jq.
# `-s` turns the jq "generator" list output into valid JSON with square brackets and commas between items.
messages=$(echo "$messages" | jq -s ".")

# Optional step to modify the compiler warnings and errors.
# See the script `dotfiles/bin/filter-rustc`, which I use mainly to reduce rustc's verbosity.
if type filter-rustc > /dev/null 2>&1; then
  if [ "$debug" == "debug" ]; then
    echo "$messages" | filter-rustc --debug
  elif [ "$debug" == "disable" ]; then
    echo "$messages" | filter-rustc --disable
  else
    messages=$(echo "$messages" | filter-rustc)
  fi
fi

# Print on the terminal using colors.
if [ "$debug" != "debug" ]; then
  echo "$messages" | jq --raw-output '.[].rendered'
fi

# Collect error lines to a file.
# `grep -v rustc` removes lines like `/rustc/9bc8..e53/library/alloc/src/macros.rs 51`,
# which occur around macro usage. Might be possible to also detect in the JSON but this is easier.
echo "$messages" | jq '
    .[].spans.[]
    | select(.is_primary==true)
    | [.file_name, .line_start]
    | @sh' \
  | sed "s/\"//g; s/'//g" \
  | grep -v rustc \
  > $dir/.errorlines
